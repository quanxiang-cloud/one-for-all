(function () {
  'use strict';
  const e = 'adoptedStyleSheets' in document;
  if (!e) {
    const e = CSSStyleSheet;
    function t(e) {
      return e.replace(/\s/g, '').match(/\@import/);
    }
    function o(e) {
      if (t(e)) {
        throw new Error("@import is not allowed when using CSSStyleSheet's replaceSync method");
      }
      if (this[r]) {
        this[r]._sheet.innerHTML = e;
        u(this);
        return this[r]._sheet.sheet;
      } else {
        throw new TypeError('replaceSync can only be called on a constructed style sheet');
      }
    }
    function s(e) {
      return new Promise((t, o) => {
        if (this[r]) {
          this[r]._sheet.innerHTML = e;
          t(this[r]._sheet.sheet);
          u(this);
        } else {
          o('replace can only be called on a constructed style sheet');
        }
      });
    }
    const r = Symbol('constructible style sheets');
    const c = Symbol('constructed');
    const h = Symbol('obsolete');
    const i = document.createElement('iframe');
    const d = Symbol('Styles');
    const a = (e) => {
      e.forEach((e) => {
        const { addedNodes: t, removedNodes: o } = e;
        o.forEach((e) => {
          if (e[c] && !e[h]) {
            setTimeout(() => {
              e[c].appendChild(e);
            });
          }
        });
        t.forEach((e) => {
          const { shadowRoot: t } = e;
          if (t && t.adoptedStyleSheets) {
            t.adoptedStyleSheets.forEach((e) => {
              t.appendChild(e[r]._sheet);
            });
          }
        });
      });
    };
    const l = new MutationObserver(a);
    l.observe(document.body, { childList: true });
    i.hidden = true;
    document.body.appendChild(i);
    const p = i.contentWindow.document.body;
    const y = (e, t) => {
      const o = t[r]._sheet.cloneNode(true);
      e.body ? (e = e.body) : null;
      o[c] = e;
      t[r]._adopters.push({ location: e, clone: o });
      e.appendChild(o);
      if (o.sheet) {
        for (const e of t[r].pastActions) {
          if (e.type === 'method') {
            o.sheet[e.key](...e.args);
          }
        }
      }
      return o;
    };
    const u = (e) => {
      e[r]._adopters.forEach((t) => {
        t.clone.innerHTML = e[r]._sheet.innerHTML;
      });
    };
    class S {
      static [Symbol.hasInstance](t) {
        return t instanceof e;
      }
      constructor() {
        this._adopters = [];
        this.pastActions = [];
        const e = document.createElement('style');
        p.appendChild(e);
        this._sheet = e;
        e.sheet[r] = this;
        if (!e.sheet.constructor.prototype.replace) {
          e.sheet.constructor.prototype.replace = s;
          e.sheet.constructor.prototype.replaceSync = o;
        }
        return e.sheet;
      }
    }
    StyleSheet.prototype.replace = s;
    e.prototype.replace = s;
    e.prototype.replaceSync = o;
    StyleSheet.prototype.replaceSync = o;
    function n(t) {
      const o = e.prototype[t];
      e.prototype[t] = function e(...s) {
        if (r in this) {
          this[r]._adopters.forEach((e) => {
            e.clone.sheet && e.clone.sheet[t](...s);
          });
          this[r].pastActions.push({ type: 'method', key: t, args: s });
        }
        return o.call(this, ...s);
      };
    }
    n('addImport');
    n('addPageRule');
    n('addRule');
    n('deleteRule');
    n('insertRule');
    n('removeImport');
    n('removeRule');
    window.CSSStyleSheet = S;
    const f = {
      get() {
        return this._adopted || [];
      },
      set(t) {
        const o = this.body ? this.body : this;
        this._adopted = this._adopted || [];
        const s = new MutationObserver(a);
        s.observe(this, { childList: true });
        if (!Array.isArray(t)) {
          throw new TypeError('Adopted style sheets must be an Array');
        }
        t.forEach((t) => {
          if (!t instanceof e) {
            throw new TypeError('Adopted style sheets must be of type CSSStyleSheet');
          }
        });
        const n = [...new Set(t)];
        const c = this._adopted.filter((e) => !n.includes(e));
        c.forEach((e) => {
          const t = e[r]._adopters.filter((e) => e.location === o)[0].clone;
          t[h] = true;
          t.parentNode.removeChild(t);
        });
        this._adopted = n;
        if (this.isConnected) {
          t.forEach((e) => y(this, e));
        }
      },
    };
    Object.defineProperty(ShadowRoot.prototype, 'adoptedStyleSheets', f);
    Object.defineProperty(Document.prototype, 'adoptedStyleSheets', f);
  }
})(undefined);
